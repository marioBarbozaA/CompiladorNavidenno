package com.navidad;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

/* Clase principal del compilador */
action code {:
  public void hola() {
    System.out.println("Hola");
  }
  public void adios() {
    System.out.println("Adios");
  }


    HashMap<String, ArrayList<String>> listaTablasSimbolos = new HashMap<String, ArrayList<String>>();
    String currentHash = "";

    public void imprimirTablasSimbolos(){
      for (String key : listaTablasSimbolos.keySet()) {
        System.out.println("Tabla de simbolos: " + key);
        System.out.println("Variables: ");
        for (String variable : listaTablasSimbolos.get(key)) {
          System.out.println(variable);
        }
        System.out.println(" ");
      }
  }
    public void cambiarContexto(String nombreFuncion) {
        currentHash = nombreFuncion;
        listaTablasSimbolos.put(nombreFuncion, new ArrayList<SymbolTableObject>());
    }

    public void annadirSymbol(SymbolTableObject symbol) {
    listaTablasSimbolos.get(currentHash).add(symbol);
  }
:}

parser code {:
  Lexer lex;

  public parser(Lexer lex) {
    this.lex = lex;
    this.symbolFactory = new DefaultSymbolFactory();
  }
:}

scan with {: return lex.next_token(); :};
init with {: :};



/* Terminales (tokens retornados por el scanner) */

/* Definición de tokens con temática navideña */


// Operadores aritméticos binarios: nombres de renos
terminal RODOLFO_SUM, TRUENO_DECREASE, RELAMPAGO_INT_DIVISION, RAYO_FLOAT_DIVISION, SALTARIN_ELEVATE, COMETA_PRODUCT, CUPIDO_MODULE; // +, -, //, /, **, *, ~(%) 
// identificador: persona
terminal PERSONA; // Identificador (nombre de variable, función, etc.)

// Operadores aritméticos unarios: grinch, quien
terminal GRINCH_DECREMENT, QUIEN_INCREMENT; // -(--), +(++)

// Operadores relacionales: elfos de santa
terminal ELFO_GREATER, ELFO_LESS, ELFO_EQUAL, ELFO_NOT_EQUAL, ELFO_GREATER_EQUAL, ELFO_LESS_EQUAL; // >, <, ==, !=, >=, <=

// Operadores lógicos: reyes magos
terminal REY_MELCHOR_COJUNCTION, REY_GASPAR_DISJUNCTION, REY_BALTASAR_NOT; // &&, ||, !

// tipos: nombres de papá noel
terminal COLACHO_INT,JOULUPUKKI_FLOAT, PAPA_NOEL_BOOLEAN, CLAUS_CHAR, SANTA_STRING, VIEJITO_PASCUERO_ARRAY; // Tipos de datos (int, string, BOOLEAN) todavia no esta 

// tipos de datos literales
terminal L_COLACHO_INT , L_JOULUPUKKI_FLOAT, L_CLAUS_CHAR, L_SANTA_STRING, L_VIEJITO_PASCUERO_ARRAY; // Tipos de datos literales (1, 1.0, true, 'a', "hola", [1,2,3]) todavia no esta
/* keyword */
terminal  NAVIDAD_ABSTRACT, FESTIVA_PUBLICL, FIESTA_PRIVATE; // Tipado de atributos y metodos abstract, public, private

// literales (valorar caso especial bool): nombres de papá noel con un prefijo l_
terminal PAPA_NOEL_TRUE, PAPA_NOEL_FALSE; // true, false 

// paréntesis: abrecuento, cierrecuento
terminal ABRE_CUENTO, CIERRE_CUENTO; // (, )

// paréntesis cuadrado: abreempaque, cierraempaque
terminal ABRE_EMPAQUE, CIERRA_EMPAQUE; // [, ]

// llaves: abreregalo, cierraregalo
terminal ABRE_REGALO, CIERRA_REGALO; // {, }

// lexemas de estructuras de control: elfo, hada, duende, envuelve, hace, revisa, envia, corta
terminal ELFO_IF, HADA_ELIF, DUENDE_ELSE, ENVUELVE_FOR, HACE_DO, REVISA_UNTIL, ENVIA_RETURN, CORTA_BREAK; // if, else, for, while, do, switch, return, break

// print, read: narra, escucha
terminal NARRA_PRINT, ESCUCHA_READ; // print, read No esta 

// lexema de fin de expresión: finregalo
terminal FIN_REGALO; // ;(|) Sirve para Finalizar 

// lexema de asignar: entrega
terminal ENTREGA; // =    //ASSIGMENT <= 

// lexema separador: separador
terminal SEPARADOR_BASTON; // , separa entre funciones, parametros, etc.

//lexema de null
terminal CARBON; // 

//Lexema de funcion
terminal FUNCTION_VILLANCICOS;

//lexema de local variable
terminal LOCAL_MUERDAGO;

//Lexeman de error
terminal MEDIAS_ERROR;
//lexema de main
terminal ESTRELLA_MAIN;

//Empezamos la Tarea 1 de definición de Gramatica
non terminal NAVIDAD;// Empezar con navidad

//No terminales para literales y tipos de datos
non terminal T_COPO, l_COPO, ARG_COPO;

//No terminales de Funciones
non terminal FUNCIONES_BOLSA_NAVIDENNA, FUNCION_REGALO, DEF_JUGUETE, CODIGO_ENVOLTURA; 

//No terminales de parametros
non terminal PARAMETROS_PALETAS, PARAMETRO_PALETA;

//lineas codigo 
non terminal LINEAS_LAZOS, LINEA_LAZO;

//Asignar variables 
non terminal ASIGNACION_GORRO;
// flujo de control
non terminal RETORNO_BURRITO_SABANERO, DO_UNTIL_FANTASMA_PASADO, FOR_FANTASMA_PRESENTE, CALL_FUNCTION_FANTASMA_FUTURO;
non terminal IF_JUANITO_ESCARCHA, ELIF_BATMAN, ELIF_MULTI_JACK_FROST, ELSE_SCROOGE; // SI, BATMAN ES UNA PELI NAVIDEÑA ;)
//expresiones 
non terminal EXPRESION_BOTA; 

non terminal  ELEMENTO_ARRAY_DULCE, l_ARRAY_TAMAL, ARRAY_OPERATION_CASCABEL; // a[0], {1,2,3}, --a[0] | ++a[1]


non terminal EXPRESION_ARIT_REGALOPRIN, EXPRESION_REL_REGALO_COMPRADO, EXPRESION_LOG_REGALO_MANUAL;



//Precedencias 

precedence left RODOLFO_SUM, TRUENO_DECREASE;
precedence left RAYO_FLOAT_DIVISION, RELAMPAGO_INT_DIVISION, COMETA_PRODUCT;
precedence left SALTARIN_ELEVATE, CUPIDO_MODULE;
precedence left GRINCH_DECREMENT, QUIEN_INCREMENT;

precedence left ELFO_EQUAL,
                ELFO_GREATER,
                ELFO_LESS,
                ELFO_GREATER_EQUAL,
                ELFO_LESS_EQUAL,
                ELFO_NOT_EQUAL, 
                ELFO_LESS_EQUAL;

precedence left REY_MELCHOR_COJUNCTION;
precedence left REY_GASPAR_DISJUNCTION;
precedence left REY_BALTASAR_NOT;

// Producción de inicio
start with NAVIDAD;


NAVIDAD::= FUNCIONES_BOLSA_NAVIDENNA 
        {:
        System.out.println("Hola, soy el parser de Navidad");
        imprimirTablasSimbolos();
        :};

T_COPO::= COLACHO_INT:tipo
 {: RESULT = tipo;:}
 | JOULUPUKKI_FLOAT:tipo
 {: RESULT = tipo;:}
 | PAPA_NOEL_BOOLEAN:tipo
 {: RESULT = tipo;:}
 | CLAUS_CHAR:tipo
 {: RESULT = tipo;:}
 | SANTA_STRING:tipo
 {: RESULT = tipo;:}
 | VIEJITO_PASCUERO_ARRAY:tipo
 {: RESULT = tipo;:};

l_COPO::= L_COLACHO_INT:lit
  {: RESULT = lit; :}
| L_JOULUPUKKI_FLOAT:lit
  {: RESULT = lit; :}
| L_CLAUS_CHAR:lit
  {: RESULT = lit; :}
| L_SANTA_STRING:lit
  {: RESULT = lit; :}
| L_VIEJITO_PASCUERO_ARRAY:lit
  {: RESULT = lit; :}
| PAPA_NOEL_TRUE:lit
  {: RESULT = lit; :}
| PAPA_NOEL_FALSE:lit
  {: RESULT = lit; :}
;

ARG_COPO::= EXPRESION_BOTA | ARG_COPO SEPARADOR_BASTON EXPRESION_BOTA;

FUNCIONES_BOLSA_NAVIDENNA::= FUNCION_REGALO | FUNCIONES_BOLSA_NAVIDENNA FUNCION_REGALO;

FUNCION_REGALO::= DEF_JUGUETE CODIGO_ENVOLTURA; // function int myFuncion (){return 1}
 
DEF_JUGUETE::= FUNCTION_VILLANCICOS:Fun ESTRELLA_MAIN ABRE_CUENTO CIERRE_CUENTO | // FUNCTION MAIN ()   
              {:
              cambiarContexto("main");
              annadirSymbol(new SymbolTableObject(new SymbolTableObject("function","main")));
              :}
              FUNCTION_VILLANCICOS:Fun T_COPO:Tipo PERSONA:id ABRE_CUENTO CIERRE_CUENTO | // function int myFuncion ()
              {:
              cambiarContexto(id.toString());
              annadirSymbol(new SymbolTableObject(new SymbolTableObject("function",Tipo.toString(), id.toString())));
              :}
              FUNCTION_VILLANCICOS:Fun T_COPO:Tipo PERSONA:id ABRE_CUENTO
              {:
              cambiarContexto(id.toString());
              annadirSymbol(new SymbolTableObject(new SymbolTableObject("function",Tipo.toString(), id.toString())));
              :} PARAMETROS_PALETAS CIERRE_CUENTO ; // function int myFuncion (int a, int b)

PARAMETROS_PALETAS::= PARAMETRO_PALETA | PARAMETROS_PALETAS SEPARADOR_BASTON PARAMETRO_PALETA;

PARAMETRO_PALETA::= T_COPO:tipo PERSONA:id 
                {:
                annadirSymbol(new SymbolTableObject(new SymbolTableObject("param",tipo.toString(), id.toString())));
                :};

CODIGO_ENVOLTURA::= ABRE_REGALO LINEAS_LAZOS CIERRA_REGALO | ABRE_REGALO CIERRA_REGALO;//{CODIGO}

RETORNO_BURRITO_SABANERO::= ENVIA_RETURN EXPRESION_BOTA;

LINEA_LAZO::= ASIGNACION_GORRO FIN_REGALO |  EXPRESION_BOTA FIN_REGALO | //a <= 1| |
              CORTA_BREAK FIN_REGALO | RETORNO_BURRITO_SABANERO FIN_REGALO | 
              FOR_FANTASMA_PRESENTE FIN_REGALO | DO_UNTIL_FANTASMA_PASADO FIN_REGALO |
              IF_JUANITO_ESCARCHA FIN_REGALO; // ESTE ULTIMO CREO QUE HAY QUE CAMBIARLO POR UNA DEFINICION 

CALL_FUNCTION_FANTASMA_FUTURO::=PERSONA ABRE_CUENTO  CIERRE_CUENTO | // myFuncion()
                                PERSONA ABRE_CUENTO ARG_COPO CIERRE_CUENTO |//myfun(...)
                                NARRA_PRINT ABRE_CUENTO ARG_COPO CIERRE_CUENTO |//print(...)
                                NARRA_PRINT ABRE_CUENTO CIERRE_CUENTO | //print()
                                ESCUCHA_READ ABRE_CUENTO ARG_COPO CIERRE_CUENTO |//read(...)
                                ESCUCHA_READ ABRE_CUENTO CIERRE_CUENTO; //read()

DO_UNTIL_FANTASMA_PASADO::= HACE_DO CODIGO_ENVOLTURA REVISA_UNTIL ABRE_CUENTO EXPRESION_BOTA CIERRE_CUENTO; // do {} until (x)

FOR_FANTASMA_PRESENTE::= ENVUELVE_FOR ABRE_CUENTO ASIGNACION_GORRO FIN_REGALO EXPRESION_BOTA FIN_REGALO EXPRESION_BOTA CIERRE_CUENTO CODIGO_ENVOLTURA; // for (a <= 0| a < 10| ++a){}

IF_JUANITO_ESCARCHA::= ELFO_IF ABRE_CUENTO EXPRESION_BOTA CIERRE_CUENTO CODIGO_ENVOLTURA | //if (a>b){}
                      ELFO_IF ABRE_CUENTO EXPRESION_BOTA CIERRE_CUENTO CODIGO_ENVOLTURA ELSE_SCROOGE |//if (a>b){} else{}
                      ELFO_IF ABRE_CUENTO EXPRESION_BOTA CIERRE_CUENTO CODIGO_ENVOLTURA ELIF_MULTI_JACK_FROST |//if (a>b){} elif(){} elif(){}
                      ELFO_IF ABRE_CUENTO EXPRESION_BOTA CIERRE_CUENTO CODIGO_ENVOLTURA ELIF_MULTI_JACK_FROST ELSE_SCROOGE;//if (a>b){} elif(){} else{}


ELIF_MULTI_JACK_FROST::= ELIF_BATMAN | ELIF_BATMAN ELIF_MULTI_JACK_FROST;
ELIF_BATMAN::= HADA_ELIF ABRE_CUENTO EXPRESION_BOTA CIERRE_CUENTO CODIGO_ENVOLTURA;
ELSE_SCROOGE::= DUENDE_ELSE CODIGO_ENVOLTURA;

LINEAS_LAZOS::= LINEA_LAZO | LINEAS_LAZOS LINEA_LAZO;

ASIGNACION_GORRO::= LOCAL_MUERDAGO T_COPO:tipo PERSONA:id    // local int a
                    {:
                    annadirSymbol(new SymbolTableObject(new SymbolTableObject("local",tipo.toString(), id.toString())));
                    :}
                    | LOCAL_MUERDAGO:local T_COPO:tipo PERSONA:id ENTREGA EXPRESION_BOTA  // local int a <= 1
                    {:
                    annadirSymbol(new SymbolTableObject(new SymbolTableObject("local",tipo.toString(), id.toString())));
                    :}
                    | LOCAL_MUERDAGO:local T_COPO:tipo ELEMENTO_ARRAY_DULCE:elem_array // local int a[1]  
                    {:
                    annadirSymbol(new SymbolTableObject(new SymbolTableObject("local",tipo.toString(),"arr", elem_array.toString())));
                    :}
                    | LOCAL_MUERDAGO:local T_COPO:tipo ELEMENTO_ARRAY_DULCE:elem_array ENTREGA l_ARRAY_TAMAL  // local int a[4] <= {1,2,3,4}
                    {:
                    annadirSymbol(new SymbolTableObject(new SymbolTableObject("local",tipo.toString(),"arr", elem_array.toString())));
                    :}
                    | PERSONA:id ENTREGA EXPRESION_BOTA // a <= 1| 
                    | ELEMENTO_ARRAY_DULCE:elem_array ENTREGA EXPRESION_BOTA // a[0] <= ++a[0]|
                    | ELEMENTO_ARRAY_DULCE:elem_array ENTREGA l_ARRAY_TAMAL; // a[4] <= {1,2,3,4}
 

EXPRESION_BOTA::= l_COPO | PERSONA |
                  ELEMENTO_ARRAY_DULCE | ABRE_CUENTO EXPRESION_BOTA CIERRE_CUENTO | 
                  CALL_FUNCTION_FANTASMA_FUTURO | EXPRESION_ARIT_REGALOPRIN | EXPRESION_REL_REGALO_COMPRADO | EXPRESION_LOG_REGALO_MANUAL;

ELEMENTO_ARRAY_DULCE::= PERSONA:id ABRE_EMPAQUE EXPRESION_BOTA CIERRA_EMPAQUE // a[0]
                    {:
                    {RESULT = id.toString();:}
                    :}; 

l_ARRAY_TAMAL::= ABRE_REGALO ARG_COPO CIERRA_REGALO;

ARRAY_OPERATION_CASCABEL::= GRINCH_DECREMENT ELEMENTO_ARRAY_DULCE | QUIEN_INCREMENT ELEMENTO_ARRAY_DULCE;

EXPRESION_ARIT_REGALOPRIN::= EXPRESION_BOTA RODOLFO_SUM EXPRESION_BOTA | // a + b
                        EXPRESION_BOTA TRUENO_DECREASE EXPRESION_BOTA | // a - b
                        EXPRESION_BOTA RELAMPAGO_INT_DIVISION EXPRESION_BOTA | // a // b
                        EXPRESION_BOTA RAYO_FLOAT_DIVISION EXPRESION_BOTA | // a / b
                        EXPRESION_BOTA SALTARIN_ELEVATE EXPRESION_BOTA | // a ** b
                        EXPRESION_BOTA COMETA_PRODUCT EXPRESION_BOTA | // a * b
                        EXPRESION_BOTA CUPIDO_MODULE EXPRESION_BOTA | // a ~ b
                        GRINCH_DECREMENT PERSONA| //--a
                        QUIEN_INCREMENT PERSONA|//++a
                        ARRAY_OPERATION_CASCABEL; // ++a[0]

EXPRESION_REL_REGALO_COMPRADO::= EXPRESION_BOTA ELFO_GREATER EXPRESION_BOTA | // a > b
                        EXPRESION_BOTA ELFO_LESS EXPRESION_BOTA | // a < b
                        EXPRESION_BOTA ELFO_EQUAL EXPRESION_BOTA | // a === b
                        EXPRESION_BOTA ELFO_NOT_EQUAL EXPRESION_BOTA | // a !== b
                        EXPRESION_BOTA ELFO_GREATER_EQUAL EXPRESION_BOTA | // a >== b
                        EXPRESION_BOTA ELFO_LESS_EQUAL EXPRESION_BOTA; // a <== b

EXPRESION_LOG_REGALO_MANUAL::= EXPRESION_BOTA REY_MELCHOR_COJUNCTION EXPRESION_BOTA | // a ^ b
                        EXPRESION_BOTA REY_GASPAR_DISJUNCTION EXPRESION_BOTA | // a # b
                        REY_BALTASAR_NOT EXPRESION_BOTA; // !a  
